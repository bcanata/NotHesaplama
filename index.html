document.addEventListener('DOMContentLoaded', function() {
  const table = document.getElementById('scoresTable');

  function loadScores() {
    const scores = JSON.parse(localStorage.getItem('scores')) || [];
    scores.forEach(score => addRow(score));
    if (!scores.length || scores[scores.length - 1].some(v => v)) addRow(); // Add blank row if last is filled
    calculateTotals(); // Calculate totals right after loading scores
  }

  function saveScores() {
    const scores = [];
    for (let i = 1; i < table.rows.length; i++) {
      const row = table.rows[i];
      const score = [...row.cells].slice(0, 5).map(cell => cell.firstChild.value || '');
      if (score.some(v => v)) scores.push(score);
    }
    localStorage.setItem('scores', JSON.stringify(scores));
  }

  function addRow(data = ['', '', '', '', '', '']) {
    const row = table.insertRow();
    for (let i = 0; i < 6; i++) {
      const cell = row.insertCell();
      if (i < 5) {
        const input = document.createElement('input');
        input.value = data[i];
        input.oninput = calculateTotals;
        cell.appendChild(input);
      } else {
        cell.textContent = data[i]; // This will be recalculated anyway
      }
    }
  }

  function calculateTotals() {
    for (let i = 1; i < table.rows.length; i++) {
      const row = table.rows[i];
      const exam1 = parseFloat(row.cells[2].firstChild.value) || 0;
      const exam2 = parseFloat(row.cells[3].firstChild.value) || 0;
      const exam3 = parseFloat(row.cells[4].firstChild.value) || 0;
      const total = (exam1 * 0.5) + (exam2 * 0.25) + (exam3 * 0.25);
      row.cells[5].textContent = total.toFixed(2);
    }
    saveScores();
  }

  table.addEventListener('input', () => {
    const lastRow = table.rows[table.rows.length - 1];
    const isLastRowFilled = [...lastRow.cells].slice(0, 5).some(cell => cell.firstChild.value);
    if (isLastRowFilled) addRow();
  });

  loadScores();
});
